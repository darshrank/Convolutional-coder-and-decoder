clearvars;
tic;
K=3;
G1=[1 1 1];
G2=[1 0 1];
k=input('enter k: ');
u=generate_in(k);
original_msg=u;
u=[u 0 0];
rate=1/2;

%probability
SNRdb=0:0.5:8;
SNRlin=10.^(SNRdb/10);
p=qfunc(sqrt(2.*rate*SNRlin));

%encoding the message
op_en=encoder(k,G1,G2,u);

op_table=[0 3; 3 0; 2 1; 1 2];
ns_table=[0 2;0 2;1 3;1 3];

Nsim=20000;

for y=1:17
    Nerr=0;
    for x=1:1:Nsim
        %passing through bsc channel
        op_bsc=bsc_channel(op_en,k,p(y));
        ip_bsc_de=[];
        for i=1:2:length(op_bsc)
          ip_bsc_de=[ip_bsc_de,op_bsc(i)*2+op_bsc(i+1)];
        end

        trellis=gen_trellis(ip_bsc_de,ns_table,op_table);
        op_bsc_de=traceback(ip_bsc_de,trellis,ns_table,op_table);

        err=cal_Nerr(k,u,op_bsc_de);
        Nerr=Nerr+err;
    end
    BER(y)=Nerr/(k*Nsim);
end
figure();
semilogy(SNRdb,BER,'o-','linewidth',2,'markerfacecolor','b','markeredgecolor','b');
xlabel('SNR per Bit ka dB'); 
ylabel('Probability of Bit Error'); 
grid on;

toc;

%For input generation
function [y] = generate_in(k)
    a=-ones(1,k);
    for i=1:1:k
        a(i)=randi(2)-1;
    end
    y=a;   
end

%bsc channel
function [y]=bsc_channel(op_en,k,p)
  for i=1:2*(k+2)
      b=rand(1);
      if(b<p)
        if(op_en(i)==1)
          op_en(i)=0;
        else
          op_en(i)=1;
        end
      end
  end
  y=op_en;
end

%encoder
function [z]=encoder(k,G1,G2,u)
  op_en=zeros(0,0);
  R=zeros(1,3);
    for i=1:k+2
      y=u(i);
      R(3)=R(2);
      R(2)=R(1);
      R(1)=y;
      B1=G1.*R;
      B2=G2.*R;
      op_en=[op_en,mod((B1(1)+B1(2)+B1(3)),2),mod((B2(1)+B2(2)+B2(3)),2)];
    end
    z=op_en;
end

%calculate hamming distance
function [HD]=hamm_dist(A,B)
HD=0;

  if(A==0)
    if(B==0)
      HD=HD+0;
    elseif(B==1 || B==2)
      HD=HD+1;
    else
      HD=HD+2;
    end  
  elseif(A==1)
    if(B==1)
      HD=HD+0;
    elseif(B==0 || B==3)
      HD=HD+1;
    else
      HD=HD+2;
    end
  elseif(A==2)
    if(B==2)
      HD=HD+0;
    elseif(B==0 || B==3)
      HD=HD+1;
    else
      HD=HD+2;
    end
  else
    if(B==3)
      HD=HD+0;
    elseif(B==1 || B==2)
      HD=HD+1;
    else
      HD=HD+2;
    end  
  end
end

function [y] = gen_trellis(ip,ns_table,op_table)
 
 trellis=zeros(4,length(ip)+1)-ones(4,length(ip)+1);
 trellis(1,1)=0; 
 
 for i=1:length(ip)
   for j=1:4
     if(trellis(j,i)==-1) %if cell value is -1 then that cell is not included in any path
        trellis(j,i)=55;
        continue;
     end
     for k=1:2
       t = hamm_dist(ip(i),op_table(j,k)); %comparison of pairwise input ip and output table
         if(trellis(ns_table(j,k)+1,i+1) == -1)
             trellis(ns_table(j,k)+1,i+1) = t+trellis(j,i); %insertion of hamming distance in the target cell
         else
             trellis(ns_table(j,k)+1,i+1) = min(t+trellis(j,i),trellis(ns_table(j,k)+1,i+1));%insertion of hamming distance in the target cell
         end     
     end
   end
 end
 y=trellis;
end

%ip is the input to decoder
%ns_table is the transition table from one state to another
%op_table is the output table for inputs from one state to another
function [y] = traceback(ip,trellis,ns_table,op_table)
    op_de=[]; %input to encoder generated by the decoder
    sz=size(ip,2)+1; %number of columns in the trellis
    last_col=[trellis(1,sz),trellis(2,sz),trellis(3,sz),trellis(4,sz)];
    last_col_min=min(last_col); %minimum of last column of the trellis
    state=0;
    for i=1:1:4
        if(last_col(i)==last_col_min)
            state=i; %state having minimum path metric
            break;
        end
    end
            
    
    for j=1:1:size(ip,2)
        state_previous=[];
        for x=1:1:2
            for y=1:1:4
                if(ns_table(y,x)==state-1)
                    state_previous=[state_previous,y-1]; %array containing the 2 possible previous states
                end
            end
        end
        input=[];
        for x=1:1:2
            for y=1:1:4
                if(ns_table(y,x)==state-1)
                    input=[input,x-1]; 
                    %array containing the inputs to go from previous state to the current state
                end
            end
        end
        sz=sz-1;
            str=ip(sz);
            str1=op_table(state_previous(1)+1,input(1)+1);
            str2=op_table(state_previous(2)+1,input(2)+1);
            %an1 and an2 are branch metrics
            an1 = hamm_dist(str,str1); 
            an2 = hamm_dist(str,str2);
            %compairing the sum of branch metric and path metric
            if(an1+trellis(state_previous(1)+1,sz)>an2+trellis(state_previous(2)+1,sz))
                a=2;
            else
                a=1;
            end
        if(a==1)
            state=state_previous(1)+1;
        else
            state=state_previous(2)+1;
        end
        op_de=[input(a),op_de];
    end
    y=op_de;
    return;
end
function [y] = cal_Nerr(k,encoder_input,decoder_output)
    nerr=0;
    for i=1:k
        if(decoder_output(i) ~= encoder_input(i))
            nerr=nerr+1;
        end
    end
    y=nerr;
    return;
end